"""
A simple xml file generator from python dictionary.

load the dictionary (or yaml) generated by the scene_gen code, which includes the object label names
"""
def dict_to_xml(problem, path):
    """
    ================================================================
    - problem
        - objects
            - obj
                - name
                - geom
                - pose (12 floating point value separated by space)
                - movable
                - grasps
                    - gc: type="side"
                        - template
                        - axis
                - sop 
                    - template: 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0
                    - axis: 0.0 0.0 1.0
                    - distance: 0
        - robots
        - workspace_bounds
    ================================================================
    extract the objects/obj which has name table* or arena
    modify the attachments
    extract all other fields from existing xml. Remove the object which are sticks. Replace the sticks with the current object
    """
    import xml.etree.ElementTree as ET
    import copy
    tree = ET.parse(path+"clutter_ml/clutter.xml")
    root = tree.getroot()
    objs_node = root[0]
    #for obj_node in objs_node:
    #print(objs_node[0].find('name'))
    keep_node = []
    remove_list = []
    for obj_node in objs_node:
        # search for the object that does not contain "table" or "arena"
        name = obj_node.find('name')
        if ('table' not in name.text) and ('arena' not in name.text):
            remove_list.append(obj_node)
    for obj_node in remove_list:
        objs_node.remove(obj_node)

    # use one object as template
    template_node = remove_list[0]

    obs_nodes = []
    table_obs = {'table1': [], 'table2': []}
    for _, obs_dicts in problem['obs'].items():
        for obs_dict in obs_dicts:
            obs_node = copy.deepcopy(template_node)
            obs_node.find('name').text = obs_dict['name']
            obs_node.find('geom').text = "stick_%s.obj" % (obs_dict['color'])
            obs_node.find('pose').text = ' '.join(obs_dict['pose'].flatten().astype('str').tolist())
            obs_nodes.append(obs_node)
            # construct table => obs_dict
            table_obs[obs_dict['table']].append(obs_dict)

    # modify the table attachment
    for obj_node in objs_node:
        name = obj_node.find('name').text
        # find if there are objects on this table
        if name not in table_obs:
            continue
        if len(table_obs[name]) == 0:
            # remove the attachments element
            attachment = obj_node.find('attachments')
            if attachment is not None:
                obj_node.remove(attachment)
            continue
        # if attachments is not there, create one
        attachment = obj_node.find('attachments')
        if attachment is None:
            attachment = ET.SubElement(obj_node, "attachments")
        # clear up the element
        attachment.clear()
        # add object names to attachments
        for obs_dict in table_obs[name]:
            name = ET.Element('name')
            name.text = obs_dict['name']
            attachment.append(name)

    # add obs to obj
    for obs_node in obs_nodes:
        objs_node.append((obs_node))

    # show the result
    def prettify(elem):
        from xml.dom import minidom
        # https://pymotw.com/2/xml/etree/ElementTree/create.html
        """Return a pretty-printed XML string for the Element.
        """
        rough_string = ET.tostring(elem, 'utf-8')
        reparsed = minidom.parseString(rough_string)
        # '\n'.join([line for line in reparsed.toprettyxml(indent=' '*2).split('\n') if line.strip()])
        return '\n'.join([line for line in reparsed.toprettyxml(indent=' '*2).split('\n') if line.strip()])
    
    return prettify(root)
    #return tree

"""
A simple PDDL code generator from python dictionary.

load the dictionary (or yaml) generated by the scene_gen code, which includes the object label names
"""


from .pddl_gen_util import *
def dict_to_pddl(problem):
    """
    example:
    =======================================================================
    problem dict:
    - name: problem_name
    - obs: 
        - color:
            [obs_dict]
            - color
            - table
            - name
            - pose
    - obs_list: list of obs_names

    ----------------------------------------------------------
    (define (problem pb7)
    (:domain clutter)
    (:objects
    table1 table2 table3 table4 -surface
    lgrippertoolframe rgrippertoolframe -manipulator
    bs1 bs2 bs3 gs1 gs2 -objs )
    (:init
    (on-surface bs1 table1) (on-surface bs2 table1) (on-surface bs3 table1)
    (on-surface gs1 table1) (on-surface gs2 table1)
    (arm-empty lgrippertoolframe) (arm-empty rgrippertoolframe))
    (:goal (and (on-surface bs1 table3) (on-surface bs2 table3) (on-surface bs3 table3) (on-surface gs1 table4) (on-surface gs2 table4)
        (arm-empty rgrippertoolframe) (arm-empty lgrippertoolframe))))
    """
    pddl_problem = PDDLProblem(problem['name'])
    pddl_domain = PDDLDomain("clutter")

    # construct all objects in the scene, also with object type
    pddl_obj_dict = {}  # format: type (e.g.: surface) => [obj_name]
    pddl_obj_dict['surface'] = ['table1', 'table2', 'table3', 'table4']
    pddl_obj_dict['manipulator'] = ['lgrippertoolframe', 'rgrippertoolframe']
    pddl_obj_dict['objs'] = problem['obs_list']
    pddl_objects = PDDLObjects(pddl_obj_dict)
    # for each object, depending on its color and assigned table, construct init predicates
    pddl_init = PDDLInit([]) # empty predicate
    # object init predicates
    for _, obs_dicts in problem['obs'].items():
        for obs_dict in obs_dicts:
            pddl_operator = PDDLSymbol("on-surface")
            pddl_operants = []
            pddl_operants.append(PDDLSymbol(obs_dict['name']))
            pddl_operants.append(PDDLSymbol(obs_dict['table']))
            pddl_pred = PDDLPredicate(pddl_operator, pddl_operants)
            pddl_init.pred_list.append(pddl_pred)
    # arm predicates
    for gripper in ["lgrippertoolframe", "rgrippertoolframe"]:    
        pddl_operator = PDDLSymbol("arm-empty")
        pddl_operants = [PDDLSymbol(gripper)]
        pddl_pred = PDDLPredicate(pddl_operator, pddl_operants)
        pddl_init.pred_list.append(pddl_pred)
    
    # construct goal prediates
    pddl_goal = PDDLGoal([])
    and_operator = PDDLSymbol("and")
    and_operants = []
    # pddl_operant here are a bunch of predicates
    color_to_table = {"blue": "table3", "green": "table4"}
    for _, obs_dicts in problem['obs'].items():
        for obs_dict in obs_dicts:
            pddl_operator = PDDLSymbol("on-surface")
            pddl_operants = []
            pddl_operants.append(PDDLSymbol(obs_dict['name']))
            # depending on color, assign table
            # blue => table3, green => table4
            table = color_to_table[obs_dict['color']]
            pddl_operants.append(PDDLSymbol(table))
            pddl_pred = PDDLPredicate(pddl_operator, pddl_operants)
            and_operants.append(pddl_pred)
    # arm predicate
    for gripper in ["lgrippertoolframe", "rgrippertoolframe"]:    
        pddl_operator = PDDLSymbol("arm-empty")
        pddl_operants = [PDDLSymbol(gripper)]
        pddl_pred = PDDLPredicate(pddl_operator, pddl_operants)
        and_operants.append(pddl_pred)

    pddl_pred = PDDLPredicate(and_operator, and_operants)
    pddl_goal.pred_list.append(pddl_pred)

    # construct problem
    pddl_content = PDDLDefineContent(pddl_domain, pddl_objects, pddl_init, pddl_goal)
    pddl_define = PDDLDefineConstruct(pddl_problem, pddl_content)

    # construct program string
    #print(pddl_define.to_string())
    return pddl_define.to_string()


def toml_dict(prob_path, problem_name, path):
    """
    domain    = "clutter_ml/clutter.pddl"
    problem   = "clutter_ml/clutter_prob0.pddl"
    scene     = "clutter_ml/clutter_prob0.xml"
    objdir    = "clutter_ml/"
    semantics = "clutter_ml.lua"
    output    = "clutter_ml_solution.json"
    perf_file = "clutter_ml.csv"
    params    = "params.toml"
    blacklist = "models/pr2_collision_blacklist.csv"
    cont_state_file = "clutter_ml_cont_state.txt"
    disc_state_file = "clutter_ml_disc_state.txt"
    time_file = "cultter_ml_time.txt"
    cfg_file = "clutter_ml_cfg.txt"
    """
    res = {}
    res['domain'] = path + 'clutter_ml/clutter.pddl'
    res['problem'] = prob_path + "clutter_%s.pddl" % (problem_name)
    res['scene'] = prob_path + "clutter_%s.xml" % (problem_name)
    res['objdir'] = path + "clutter_ml/"
    res['semantics'] = path + "clutter_ml.lua"
    res['output'] = prob_path + "clutter_ml_solution.json"
    res['perf_file'] = prob_path + "clutter_ml.csv"
    res['params'] = path + "params.toml"
    res['blacklist'] = path + "models/pr2_collision_blacklist.csv"
    res['cont_state_file'] = prob_path + "clutter_ml_cont_state.txt"
    res['disc_state_file'] = prob_path + "clutter_ml_disc_state.txt"
    res['time_file'] = prob_path + "cultter_ml_time.txt"
    res['cfg_file'] = prob_path + "clutter_ml_cfg.txt"

    return res

def main():
    # unit testing for xml
    dict_to_xml(None)


if __name__ == "__main__":
    main()